package com.lzz.tranning;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;

/**
 * 为了不断优化推荐效果，今日头条每天要存储和处理海量数据。假设有这样一种场景：
 * 我们对用户按照它们的注册时间先后来标号，对于一类文章，每个用户都有不同的喜好值，
 * 我们会想知道某一段时间内注册的用户（标号相连的一批用户）中，有多少用户对这类文章喜好值为k。
 * 因为一些特殊的原因，不会出现一个查询的用户区间完全覆盖另一个查询的用户区间(不存在L1<=L2<=R2<=R1)。
 * 
 * 
 * 输入描述: 输入： 第1行为n代表用户的个数 第2行为n个整数，第i个代表用户标号为i的用户对某类文章的喜好度 第3行为一个正整数q代表查询的组数
 * 第4行到第（3+q）行，每行包含3个整数l,r,k代表一组查询，即标号为l<=i<=r的用户中对这类文章喜好值为k的用户的个数。 数据范围n <=
 * 300000,q<=300000 k是整型 输出描述: 输出： 一共q行，每行一个整数代表喜好值为k的用户的个数
 * 
 * @author CunsiALIEN
 *
 */
public class UserPreference {
	public static Map<Integer, List<Integer>> map = new HashMap<Integer, List<Integer>>();
	public static Queue<Integer> queue = new LinkedList<>();

	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
		int i[] = new int[n];
		for (int x = 0; x < n; x++) {
			i[x] = sc.nextInt();
		}
		addToMap(i);
		int q = sc.nextInt();
		for (int j = 0; j < q; j++) {
			int l = sc.nextInt();
			int r = sc.nextInt();
			int k = sc.nextInt();
			userPreference(l, r, k);
		}
		for (Integer integer : queue) {
			System.out.println(integer);
		}
		sc.close();
	}

	public static void addToMap(int[] i) {
		for (int x = 0; x < i.length; x++) {
			if (!map.containsKey(i[x])) {
				List<Integer> list = new LinkedList<>();
				list.add(x + 1);
				map.put(i[x], list);
			} else {
				List<Integer> list = map.get(i[x]);
				list.add(x + 1);
			}
		}
	}

	public static void userPreference(int l, int r, int k) {
		int count = 0;
		List<Integer> list = map.get(k);
		if (list != null) {
			for (Integer integer : list) {
				if (integer >= l && integer <= r) {
					count++;
				}
			}	
		}
		queue.add(count);
	}
}
